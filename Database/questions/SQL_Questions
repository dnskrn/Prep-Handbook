Questions
=========
DDL -> CREATE, ALTER, DROP, TRUNCATE, COMMENT, RENAME, and GRANT
DML -> INSERT, UPDATE, DELETE, and MERGE
TCL -> COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION, and AUTOCOMMIT

1. What is DML, and what are its types in Oracle?
DML stands for Data Manipulation Language. It is used to manipulate data in the database. In Oracle, DML
includes commands like INSERT, UPDATE, DELETE, and MERGE.

2. Explain the difference between DDL and DML in Oracle.
1. DDL (Data Definition Language) is used to define and manage the structure of database objects like tables,
indexes, views, etc. Examples of DDL commands include CREATE, ALTER, DROP, TRUNCATE, etc.

2. DML (Data Manipulation Language), on the other hand, is used to manipulate data stored in the database.
Examples of DML commands include INSERT, UPDATE, DELETE, MERGE, etc.

3. What is TCL, and what are its types in Oracle?
TCL stands for Transaction Control Language. It is a category of SQL commands that deal with transactions
within a database. In Oracle, TCL commands primarily include COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION,
and AUTOCOMMIT.

4. Differentiate between DELETE and TRUNCATE in Oracle.
DELETE is a DML command that removes specific rows from a table based on a condition, and it can be rolled
back using a ROLLBACK statement. TRUNCATE is a DDL command that removes all rows from a table and releases
the storage space, and it cannot be rolled back.

5. Explain the COMMIT and ROLLBACK statements in Oracle.
1. COMMIT is a TCL command used to permanently save any changes made during the current transaction. Once a
COMMIT statement is executed, the changes become permanent in the database.

2. ROLLBACK, on the other hand, is a TCL command that reverts any changes made during the current transaction
back to the last COMMIT point  or the beginning of the transaction if no COMMIT has been issued.

6. What is the purpose of the SAVEPOINT statement in Oracle?
SAVEPOINT is a TCL command used to define a point within a transaction to which you can later roll back. It
allows you to partially roll back a transaction instead of rolling back the entire transaction.

7. Explain the CASCADE CONSTRAINTS option in Oracle when dropping a table.
CASCADE CONSTRAINTS is an option used with the DROP TABLE statement in Oracle. When CASCADE CONSTRAINTS is
specified, it will automatically drop all the referential integrity constraints (foreign key constraints)
that refer to the primary or unique key columns of the table being dropped.

8. What is SET TRANSACTION in TCL?
SET TRANSACTION is used to specify properties for a transaction, such as isolation level, access mode, and
transaction name. It allows you to control various aspects of how transactions are processed by the database.

9. What is AUTOCOMMIT in TCL?
AUTOCOMMIT is a mode that can be enabled or disabled in Oracle. When AUTOCOMMIT is enabled, each individual
SQL statement is treated as a separate transaction, and it is automatically committed after execution. When
AUTOCOMMIT is disabled, you need to explicitly issue a COMMIT or ROLLBACK command to end the transaction.

10. Explain the difference between UPDATE and MERGE statements.
Both modify existing data, but UPDATE edits specific rows based on a WHERE clause, while MERGE can perform
INSERT, UPDATE, or DELETE based on a matched condition. MERGE is generally more concise for complex operations.

11. Write a query to create a table named Customers with columns for customer_id (number), customer_name
(varchar2), and city (varchar2)?
CREATE TABLE Customers (
  customer_id NUMBER PRIMARY KEY,
  customer_name VARCHAR2(50) NOT NULL,
  city VARCHAR2(30)
);

12. Describe the concept of constraints in Oracle and their types.
Constraints enforce data integrity within tables. Common types include:
1. PRIMARY KEY: Ensures unique values in a column or set of columns.
2. FOREIGN KEY: Creates a link between two tables, referencing a PRIMARY KEY in another table.
2. NOT NULL: Prevents null values in a column.

13. Explain the concept of ACID properties in transactions.
ACID stands for below,
Atomicity: Transactions are indivisible units of work, either all succeed or all fail.
Consistency: Transactions maintain data integrity by following defined rules.
Isolation: Transactions are isolated from each other, preventing interference.
Durability: Once committed, changes made by a transaction are permanent.

14. What is a subquery?
A subquery is a query nested within another query. It is enclosed within parentheses and can be used in
various parts of a SQL statement, such as the WHERE clause, FROM clause, SELECT clause, or HAVING clause.

15. What are the types of subqueries in Oracle SQL?
1. Single-row subquery: A subquery that returns only one row and one column.
2. Multi-row subquery: A subquery that returns multiple rows but only one column.

16. What is the difference between a correlated and a non-correlated subquery?
1. Non-correlated subquery: A subquery that can be executed independently of the outer query and does not
reference columns from the outer query.
2. Correlated subquery: A subquery that depends on the outer query and references columns from the outer
query.

17. How can you use a subquery in the WHERE clause?
You can use a subquery in the WHERE clause to filter rows based on the result of the subquery.
For example:
SELECT column1 FROM table1 WHERE column2 = (SELECT column3 FROM table2 WHERE condition);

18. What is the result of a subquery that returns NULL values?
If a subquery returns NULL values, it is treated as if it returned an empty set. For example, if a subquery
in the WHERE clause does not match any rows, the outer query will not return any rows.

19. When would you use a subquery instead of a join?
Subqueries are often used when the result set of the inner query is dynamic and depends on the data in the
database or when the query logic is more straightforward to express using a subquery. Joins are typically
used when joining tables based on common columns.

20. What is the EXISTS and IN operators, and how is it used with subqueries?
The EXISTS operator is used to test for the existence of rows returned by a subquery. It returns TRUE if
the subquery returns at least one row; otherwise, it returns FALSE. The EXISTS operator is commonly used
in correlated subqueries.
SELECT column1 FROM table1 WHERE EXISTS (SELECT * FROM table2 WHERE condition);

The IN operator is used to filters rows in the outer query based on whether their values are present in
the subquery result set.
SELECT column1 FROM table1 WHERE IN (SELECT * FROM table2 WHERE condition);

21. Write a query to find all employees who earn more than the average salary in the company.
SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);

22. Find the name of the department with the highest number of employees.
SELECT department_name FROM departments WHERE number_of_employees = (SELECT MAX(number_of_employees)
FROM departments);

23. Identify customers who haven't placed any orders in the last 6 months.
SELECT * FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o
WHERE o.customer_id = c.customer_id AND order_date > SYSDATE - 180);

24. What is a join in Oracle SQL?
A join is a SQL operation used to combine rows from two or more tables based on a related column
between them.

25. What are the different types of joins in Oracle SQL?
1. Inner Joins (Simple Join)
2. Left Outer Join (Left Join)
3. Right Outer Join (Right Join)
4. Full Outer Join (Full Join)
5. Equijoins
6. Self Joins
7. Cross Joins (Cartesian Products)
8. Antijoins
9. Semijoins

26. What is Inner Join?
Inner Join is the simplest and most common type of join. It is also known as simple join. It returns
all rows from multiple tables where the join condition is met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns FROM table1 INNER JOIN table2 ON table1.column = table2.column;

SELECT suppliers.supplier_id, suppliers.supplier_name, orders.order_number
FROM suppliers INNER JOIN orders
ON suppliers.supplier_id = orders.supplier_id;

Output
======
supplier_id   | supplier_name        | order_number
---------------------------------------------------
1             | Bata Shoes           | 101
2             | Walkaro Slippers     | 102

Explanation:
============
Supplier ID 1 ("Bata Shoes") has an order associated with it, which is Order Number 101.
Supplier ID 2 ("Walkaro Slippers") has an order associated with it, which is Order Number 102.
Supplier ID 3 ("Bombay Dying Shocks") does not have any orders associated with it, so it does not appear
in the result set.

27. What is Left Outer Join / Left Join?
Left Outer Join returns all rows from the left (first) table specified in the ON condition and only
those rows from the right (second) table where the join condition is met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns  FROM table1 LEFT [OUTER] JOIN table2 ON table1.column = table2.column;

SELECT suppliers.supplier_id, suppliers.supplier_name, orders.order_number
FROM suppliers LEFT [OUTER] JOIN order
ON suppliers.supplier_id = orders.supplier_id;

Output
======
supplier_id   | supplier_name        | order_number
---------------------------------------------------
1             | Bata Shoes           | 101
2             | Walkaro Slippers     | 102
3             | Bombay Dying Shocks  | NULL

Explanation:
============
Supplier ID 1 ("Bata Shoes") has an order associated with it, which is Order Number 101.
Supplier ID 2 ("Walkaro Slippers") has an order associated with it, which is Order Number 102.
Supplier ID 3 ("Bombay Dying Shocks") does not have any orders associated with it, so the order number
column shows NULL for this supplier.

28. What is Right Outer Join / Right Join?
The Right Outer Join returns all rows from the right-hand table specified in the ON condition and only
those rows from the other table where the join condition is met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns FROM table1 RIGHT [OUTER] JOIN table2 ON table1.column = table2.column;

SELECT orders.order_number, orders.city, suppliers.supplier_name
FROM suppliers RIGHT OUTER JOIN orders
ON orders.supplier_id = suppliers.supplier_id;

Output
======
order_num   | city       | supplier_name
-----------------------------------------
101         | Allahabad  | Bata Shoes
102         | Kanpur     | Walkaro Slippers

Explanation:
============
Order 101 is associated with Supplier ID 1, which corresponds to "Bata Shoes" in the suppliers table.
Order 102 is associated with Supplier ID 2, which corresponds to "Walkaro Slippers" in the suppliers table.
Since there are no orders associated with Supplier ID 3, the supplier information for Supplier ID 3 ("Bombay
Dying Shocks") will not appear in the output, resulting in NULL values for supplier_name in those rows.

29. What is Full Outer Join / Full Join?
The Full Outer Join returns all rows from the left hand table and right hand table. It places NULL
where the join condition is not met.

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

Orders Table
============
order Num       Supplier Id         City
-----------------------------------------
101             1                   Allahabad
102             2                   Kanpur

SELECT columns FROM table1 FULL [OUTER] JOIN table2 ON table1.column = table2.column;

SELECT suppliers.supplier_id, suppliers.supplier_name, orders.order_number
FROM suppliers
FULL OUTER JOIN orders
ON suppliers.supplier_id = orders.supplier_id;

Output
======
supplier_id   | supplier_name        | order_number
---------------------------------------------------
1             | Bata Shoes           | 101
2             | Walkaro Slippers     | 102
3             | Bombay Dying Shocks  | NULL
NULL          | NULL                 | NULL

Explanation:
============
Supplier ID 1 ("Bata Shoes") has an order associated with it, which is Order Number 101.
Supplier ID 2 ("Walkaro Slippers") has an order associated with it, which is Order Number 102.
Supplier ID 3 ("Bombay Dying Shocks") does not have any orders associated with it, so it appears in the
result set with a NULL value for the order number.
The last row with NULL values represents an order that does not have a corresponding supplier. This occurs
because of the FULL OUTER JOIN, which includes all rows from both tables, regardless of whether there is a
match.

30. What is EQUI JOIN in Oracle?
Oracle Equi join returns the matching column values of the associated tables. It uses a comparison operator
in the WHERE clause to refer equality.

Equi join also can be performed by using JOIN keyword followed by ON keyword and then specifying names of the
columns along with their associated tables to check equality.

Agent Table
===========
Agent_Id    Agent_Name    Agent_City
------------------------------------
1           John          Texas
2           Alex          Missouri
3           Erick         New Jersey

Customer Table
==============
Cust_Id     FirstName     LastName
----------------------------------
3           Erick         Samson
4           Richard       Peterson

SELECT column_list FROM table1, table2 WHERE table1.column_name = table2.column_name;
SELECT * FROM table1 JOIN table2 [ON (join_condition)]

SELECT agents.agent_city, customer.LastName, customer.FirstName
FROM Agent, Customer WHERE agents.Agent_Id = customer.Cust_Id;

SELECT agents.agent_city, customer.LastName, customer.FirstName
FROM Agent JOIN Customer ON agents.Agent_Id = customer.Cust_Id;

Output
======
Agent_City    LastName    FirstName
-----------------------------------
New Jersey    Samson      Erick

Explanation:
============
1. The query performs an inner join between the Agent table and the Customer table based on matching Agent_Id
from the Agent table with Cust_Id from the Customer table.
2. Only one row is returned because there's a match between Agent_Id 3 in the Agent table and Cust_Id 3 in the
Customer table.
3. The resulting row includes the Agent_City from the Agent table and the LastName and FirstName from the
Customer table for the matched customer.

31. What is Self Join in Oracle?
A self-join is a join operation where a table is joined with itself. This is useful when you want to compare
rows within the same table or find hierarchical relationships within the table.

Employees Table
===============
Employee_ID  |  Employee_Name  |  Manager_ID
--------------------------------------------
1            |  John           |  3
2            |  Alice          |  1
3            |  Smith          |  NULL
4            |  Emily          |  3
5            |  Bob            |  2

In this table, the Manager_ID column represents the ID of the manager for each employee. The manager of an
employee is also an employee in the same table.

SELECT e.Employee_Name AS Employee, m.Employee_Name AS Manager
FROM Employees e INNER JOIN Employees m ON e.Manager_ID = m.Employee_ID;

SELECT e.Employee_Name AS Employee, m.Employee_Name AS Manager
FROM Employees e, Employees m
WHERE e.Manager_ID = m.Employee_ID;

Output
======
Employee  |  Manager
---------------------
John      |  Smith
Alice     |  John
Smith     |  NULL
Emily     |  Smith
Bob       |  Alice

Explanation
============
We are selecting two columns, aliased as Employee and Manager, which represent the employee's name and their
manager's name, respectively.

We're performing an inner join between the Employees table, aliased as e, and itself, aliased as m.

The ON clause specifies the condition for the join, which is e.Manager_ID = m.Employee_ID. This means that we
are matching each employee's Manager_ID with another employee's Employee_ID, effectively finding the manager
for each employee.

Since it's an inner join, only rows with matching Manager_ID and Employee_ID values will be included in the
result set. This means that employees without managers or managers without employees will not appear in the
result.

Finally, we alias the columns to distinguish between the employee's name (Employee) and the manager's name
(Manager).

32. What is Cross Join in Oracle?
The CROSS JOIN specifies that all rows from first table join with all of the rows of second table. If there
are "x" rows in table1 and "y" rows in table2 then the cross join result set have x*y rows. It normally happens
when no matching join columns are specified.

In simple words you can say that if two tables in a join query have no join condition, then the Oracle returns
their Cartesian product.

SELECT * FROM table1 CROSS JOIN table2;
SELECT * FROM table1, table2;

Customer Table
==============
Cust_Id     FirstName     LastName
----------------------------------
1           Erick         Samson
2           Richard       Peterson

Suppliers Table
===============
Supplier Id     Supplier Name           Supplier Address
-------------------------------------------------------
1               Bata Shoes              Agra
2               Walkaro Slippers        Delhi
3               Bombay Dying Shocks     Mumbai

SELECT * FROM Suppliers CROSS JOIN Customer;

Output
======
Supplier Id  |  Supplier Name         |  Supplier Address     |  Cust_Id  |  FirstName  |  LastName
-----------------------------------------------------------------------------------------------------
1            |  Bata Shoes            |  Agra                 |  1        |  Erick      |  Samson
2            |  Walkaro Slippers      |  Delhi                |  1        |  Erick      |  Samson
3            |  Bombay Dying Shocks   |  Mumbai               |  1        |  Erick      |  Samson
1            |  Bata Shoes            |  Agra                 |  2        |  Richard    |  Peterson
2            |  Walkaro Slippers      |  Delhi                |  2        |  Richard    |  Peterson
3            |  Bombay Dying Shocks   |  Mumbai               |  2        |  Richard    |  Peterson

Explanation:
============
1. Each row from the Suppliers table is combined with every row from the Customer table.
2. The resulting table has all possible combinations of supplier and customer data.
3. For each supplier, there is a row for each customer, resulting in a total of 3 suppliers * 2 customers = 6
rows in the output.

33. What is AntiJoin in Oracle?
Anti-join is used to make the queries run faster. It is a very powerful SQL construct Oracle offers for
faster queries.
Anti-join between two tables returns rows from the first table where no matches are found in the second
table. It is opposite of a semi-join. An anti-join returns one copy of each row in the first table for
which no match is found.
Anti-joins are written using the NOT EXISTS or NOT IN constructs.

Department Table
================
Department_Id       Department_Name
-----------------------------------
1                   HR
2                   Finance
3                   Management

Employee Table
==============
Employee_Id     First_Name      Last_Name       Department_Id
-------------------------------------------------------------
1               John            Smith           1
2               Alex            PeterSon        -
3               Erick           Son             2

SELECT department.department_id, department.department_name
FROM     department
WHERE    NOT EXISTS
(SELECT 1 FROM employee WHERE employee.department_id = department.department_id)
ORDER BY department.department_id;

Output
======
Department_Id | Department_Name
--------------------------------
3             | Management

Explanation:
============
1. SELECT department.Department_Id, department.Department_Name: This part of the query selects the
Department_Id and Department_Name columns from the Department table.
2. FROM Department: We specify the Department table as the source of data.
3. WHERE NOT EXISTS: This clause is used to filter out departments for which the subquery does not
return any rows.
4. SELECT 1 FROM Employee WHERE Employee.Department_Id = Department.Department_Id: This is a subquery
that checks if there are any rows in the Employee table where the Department_Id matches the
Department_Id of the outer query. If no such rows exist, the NOT EXISTS condition evaluates to true
for that department.
5. ORDER BY department.Department_Id: This orders the result set by the Department_Id in ascending
order.

34. What is Semi Join in Oracle?
Semi-join is introduced in Oracle 8.0. It provides an efficient method of performing a WHERE EXISTS
sub-query.
A semi-join returns one copy of each row in first table for which at least one match is found.
Semi-joins are written using the EXISTS construct.

Department Table
================
Department_Id       Department_Name
-----------------------------------
1                   HR
2                   Finance
3                   Management

Employee Table
==============
Employee_Id     First_Name      Last_Name       Department_Id
-------------------------------------------------------------
1               John            Smith           1
2               Alex            PeterSon        -
3               Erick           Son             2

SELECT department.department_id, department.department_name
FROM     department
WHERE    EXISTS
(SELECT 1 FROM employee WHERE employee.department_id = department.department_id)
ORDER BY department.department_id;

Output
======
Department_Id   Department_Name
--------------------------------
1               HR
2               Finance

Explanation
===========
1. The Department table has three departments: HR, Finance, and Management.
2. The Employee table has two records with valid Department_Id values (1 and 2).
3. The query retrieves departments from the Department table where there is at least one corresponding
record in the Employee table.
4. Departments with Department_Id 1 (HR) and 2 (Finance) have employees associated with them, so they
satisfy the condition and are returned as the output. The department with Department_Id 3 (Management)
does not have any employees associated with it, so it is excluded from the result.

34. What is the difference between INNER JOIN and OUTER JOIN?
1. INNER JOIN returns only the rows where there is a match in both tables.
2. OUTER JOIN returns all rows from one or both tables, depending on the type of outer join, and includes
unmatched rows with NULL values.

35. What is a self-join, and how is it used?
A self-join is a join in which a table is joined with itself. It is often used to compare rows within
the same table or to find hierarchical relationships within the table.

36. What is the difference between a join condition specified in the WHERE clause and the ON clause?
1. The join condition specified in the WHERE clause is used for implicit joins, where tables are listed with
commas in the FROM clause.
2. The ON clause is used for explicit joins (ANSI SQL syntax) and specifies the join condition directly after
the JOIN keyword.

37. Describe the common aggregate functions in Oracle (COUNT, SUM, AVG, MIN, MAX)?
1. AVG(): Calculates the average value of a numeric column.
2. COUNT(): Counts the number of rows in a result set or the number of non-null values in a column.
3. MAX(): Returns the maximum value in a set of values.
4. MIN(): Returns the minimum value in a set of values.
5. SUM(): Calculates the sum of values in a set.

38. Describe about the arithmetic operators in oracle?
In Oracle SQL, arithmetic operators are used to perform mathematical operations on numeric
data types. Here are the commonly used arithmetic operators:
Addition (+): The addition operator is used to add two numeric values together.
Example:
SELECT 5 + 3; -- Output: 8
Subtraction (-): The subtraction operator is used to subtract one numeric value from another.
Example:
SELECT 10 - 4; -- Output: 6
Multiplication (*): The multiplication operator is used to multiply two numeric values together.
Example:
SELECT 5 * 4; -- Output: 20
Division (/): The division operator is used to divide one numeric value by another.
Example:
SELECT 20 / 5; -- Output: 4
Integer Division (DIV): The integer division operator is used to divide one numeric value by
another and return only the integer part of the result.
Example:
SELECT 20 DIV 3; -- Output: 6
Modulus (MOD): The modulus operator returns the remainder of a division operation.
Example:
SELECT 20 MOD 3; -- Output: 2 (20 divided by 3 leaves a remainder of 2)
Exponentiation () or POWER()**: The exponentiation operator or the POWER() function is used to
raise a numeric value to the power of another numeric value.
Example:
SELECT POWER(2, 3); -- Output: 8 (2 raised to the power of 3)
SELECT 2 ** 3; -- Output: 8 (alternative syntax)

39. Describe the use of Like clause in Oracle?
The LIKE clause in SQL is used to search for a specified pattern in a column. It is commonly
used in WHERE clauses to filter rows based on patterns rather than exact matches. The LIKE
clause is particularly useful when you want to perform wildcard searches or search for patterns
within text data.

SELECT column1, column2 FROM table_name WHERE column_name LIKE pattern;

SELECT * FROM products WHERE product_name LIKE 'Apple%';
-- This query will match any product_name that starts with 'Apple'.

SELECT * FROM products WHERE product_name LIKE '%Apple%';
-- This query will match any product_name that has 'Apple' anywhere in name.

SELECT * FROM products WHERE product_name LIKE '%Apple';
-- This query will match any product_name that ends with 'Apple'.

SELECT * FROM customers WHERE phone_number LIKE '555-1_';
-- This query will match phone numbers in the format '555-1' followed by any single character.

SELECT * FROM employees WHERE last_name LIKE '[C-E]%';
-- This query will match last names starting with 'C', 'D', or 'E'.

SELECT * FROM products WHERE product_name LIKE '[^A-D]%';
-- This query will match product names that do not start with 'A', 'B', 'C', or 'D'.

40. Describe the SET operators available in Oracle?
SET operators are used to combine the results of two or more SELECT statements. These operators
allow you to perform set operations, such as union, intersection, and difference, on the result
sets of queries. Here are the SET operators available in Oracle:

UNION: The UNION operator is used to combine the results of two or more SELECT statements into a
single result set. It removes duplicate rows from the result set by default.

UNION ALL: The UNION ALL operator is similar to UNION but does not remove duplicate rows from the
result set. It includes all rows from both SELECT statements, even if they are duplicates.

INTERSECT: The INTERSECT operator is used to return the intersection of the result sets of two or
more SELECT statements. It returns only the rows that appear in all result sets.

MINUS (or EXCEPT): The MINUS operator is used to return the difference between the result sets of
two SELECT statements. It returns only the rows that appear in the first result set but not in the
second result set.

41. What is a View in Oracle. How to create a View and retrieve the data from the View?
A view is a virtual table that is based on the result set of a SELECT query. A view does not store
data itself; instead, it retrieves data dynamically from one or more underlying tables or other
views. Views are useful for simplifying complex queries, providing a layer of abstraction over
underlying data, and restricting access to certain columns or rows.

CREATE VIEW employee_view AS SELECT employee_id, first_name, last_name, hire_date
FROM employees WHERE department_id = 30;

SELECT * FROM employee_view;

42. What is the use of Order By Clause in Oracle?
The ORDER BY clause in Oracle is used to sort the result set returned by a query based on one or
more columns. It allows you to specify the order in which you want the rows to be displayed, either
in ascending (default) or descending order.

SELECT FirstName, LastName FROM Employees ORDER BY LastName;
SELECT customer_name, order_total FROM orders ORDER BY order_total DESC;

Null Handling:
==============
By default, NULL values are sorted last in ascending order (ASC) and first in descending order (DESC).
You can explicitly control null handling using the NULLS FIRST or NULLS LAST keywords after the column
name:
ORDER BY column_name ASC NULLS LAST  -- Sort ascending, NULLs last
ORDER BY column_name DESC NULLS FIRST -- Sort descending, NULLs first

43. Explain the difference between SYSDATE and CURRENT_DATE in Oracle SQL.
1. SYSDATE returns the current date and time from the system clock, including fractional seconds.
2. CURRENT_DATE also returns the current date but without the time portion (it is truncated to
midnight).

44. What is the use of Group By Clause in Oracle?
The GROUP BY clause in Oracle's SQL (Structured Query Language) is used to categorize and summarize
data based on specific columns. It groups rows with matching values in the specified columns,
allowing you to perform aggregate operations (like COUNT, SUM, AVG, MIN, MAX) on those groups.

SELECT department_name, COUNT(*) AS employee_count FROM employees GROUP BY department_name;

This query selects the department_name and uses COUNT(*) to count the number of employees
(represented by employee_count) in each department from the employees table. The results are
grouped by department_name.

45. What is the difference between WHERE and HAVING clauses?
1. WHERE filters rows before grouping (based on individual row values).
2. HAVING filters groups after grouping (based on aggregate values).

46. What is the use of Having Clause in Oracle?
The HAVING clause is used to filter groups of data created by the GROUP BY clause. It allows
you to specify conditions that must be met for a group to be included in the final result set.

Here's how it works:
1. Grouping: The GROUP BY clause categorizes rows with matching values in the specified columns.
2. Aggregate Calculations: Aggregate functions (like COUNT, SUM, AVG) are applied to each group.
3. HAVING Filtering: The HAVING clause filters the groups based on a condition that involves the
aggregate values or columns used in the GROUP BY. Only groups that satisfy the HAVING condition
are included in the final results.

SELECT department_name, COUNT(*) AS employee_count
FROM employees GROUP BY department_name
HAVING COUNT(*) > 5;

47. What is trigger in Oracle?
A trigger is a special type of PL/SQL program that automatically executes ("fires") in response
to a specific event or condition. These events are typically related to data manipulation
operations performed on tables or views within the database.

How Triggers Work:
==================
1. Trigger Definition: You create a trigger using the CREATE TRIGGER statement. This statement
specifies the trigger's:
    1. Name: Unique identifier for the trigger.
    2. Event: The DML (Data Manipulation Language) operation (e.g., INSERT, UPDATE, DELETE) or
    other events (e.g., system events) that trigger the code execution.
    3. Timing: When the trigger fires relative to the event (e.g., BEFORE or AFTER the DML statement).
    4. Body: The PL/SQL code block that defines the actions to be performed when the trigger fires.
2. Event Occurs: When a qualifying DML operation or other event happens on the associated table or
view.
3. Trigger Execution: Oracle automatically executes the PL/SQL code defined in the trigger's body.

Example
=======
CREATE OR REPLACE TRIGGER Salary_Check
BEFORE INSERT OR UPDATE ON Employees
FOR EACH ROW
BEGIN
    IF :New.Salary < 30000 OR :New.Salary > 100000 THEN
        RAISE APPLICATION_ERROR(-20001, 'Salary must be between 30,000 and 100,000');
    END IF;
END;
/

Explanation:
============
1. This trigger named salary_check fires before an INSERT or UPDATE on the employees table.
2. It checks if the new salary value (NEW.Salary) falls within the specified range (30,000
- 100,000).
3. If not, it raises an application error to prevent the invalid data from being saved.

Types
=====
1. DML Triggers
2. DDL Triggers

CREATE OR REPLACE TRIGGER Add_Row_TR
BEFORE UPDATE ON ACCOUNTS
FOR EACH ROW
BEGIN
    INSERT INTO TRANSACTIONS
    (TxnId, ActNo, TxnDate, Amt, Bal)
    values (ac_seq.nextval, :new.ActNo, sysdate, abs(:new.balance - :old.balance), :new.balance);
END
/

48. What is the use of Sequence in Oracle?
A sequence in Oracle is a database object that generates a unique, ordered series of numeric values.
It's a valuable tool for ensuring that every row inserted into a table gets a distinct identifier,
even when multiple users are concurrently adding data.

CREATE SEQUENCE sequence_name
START WITH initial_value  -- Starting value
INCREMENT BY increment_value  -- Amount to increment by (default 1)
MINVALUE minimum_value (optional)  -- Lower limit
MAXVALUE maximum_value (optional)  -- Upper limit
[CYCLE | NOCYCLE]  -- Whether to wrap around after reaching max value
[CACHE size] (optional) -- Pre-allocate a pool of sequence numbers

START WITH: The initial value for the sequence.
INCREMENT BY: The amount to increment by for each new value (default 1).
MINVALUE (optional): The lowest allowed value in the sequence.
MAXVALUE (optional): The highest allowed value in the sequence.
CYCLE: Allows the sequence to wrap around and start over after reaching the MAXVALUE.
NOCYCLE (default): Prevents the sequence from wrapping around; an error occurs when MAXVALUE
is reached.
CACHE (optional): Pre-allocates a pool of sequence numbers for improved performance.

-- Basic sequence (starts at 1, increments by 1, no limits)
CREATE SEQUENCE my_sequence;

-- Sequence with starting value and increment
CREATE SEQUENCE order_seq
START WITH 100  -- Starting value
INCREMENT BY 5;  -- Increment by 5

-- Sequence with limits and no wrapping
CREATE SEQUENCE product_id_seq
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 9999  -- Maximum allowed value
NOCYCLE;        -- Disallow wrapping around

-- Sequence with wrapping around
CREATE SEQUENCE customer_id_seq
START WITH 1000
INCREMENT BY 1
MAXVALUE 9999
CYCLE;          -- Allow wrapping around after reaching max

49. What is the use of Indexes in Oracle?
Indexes are special database structures that significantly improve the performance of queries
by providing a faster way to locate specific data in tables. They act like an index in a book,
pointing to the relevant information without having to scan the entire table.

**1. Basic Index on a Single Column:**
=======================================
CREATE INDEX idx_customer_name ON customers(customer_name);
This code creates an index named `idx_customer_name` on the `customer_name` column of the
`customers` table. This will improve searches and filtering based on customer names.

**2. Index on Multiple Columns:**
=================================
CREATE INDEX idx_order_details ON orders(customer_id, order_date);
This index named `idx_order_details` is created on two columns: `customer_id` and `order_date`
in the `orders` table. This can be useful for queries that filter or join data based on both
customer and order date.

**3. Unique Index (enforces uniqueness):**
==========================================
CREATE UNIQUE INDEX ux_email ON users(email);
This creates a unique index named `ux_email` on the `email` column in the `users` table. This
ensures that no duplicate email addresses exist in the table.

**4. Including a Subset of Characters:**
========================================
CREATE INDEX idx_product_name_start ON products(SUBSTR(product_name, 1, 10));

This index named `idx_product_name_start` is created on the first 10 characters
(`SUBSTR(product_name, 1, 10)`) of the `product_name` column in the `products` table.
This can be helpful for searches that start with specific keywords.

50. What is Stored Procedures in Oracle?
Stored procedures are pre-compiled PL/SQL program blocks that encapsulate a specific set of
database operations. They act like reusable mini-programs stored within the database.

Stored procedures in Oracle are named PL/SQL blocks that perform one or more tasks or operations.
They allow you to encapsulate a set of SQL and procedural statements into a single unit, which
can be invoked repeatedly by applications or other database objects. Stored procedures enhance
code modularity, reusability, and security by centralizing database logic.

Example
=======
CREATE OR REPLACE PROCEDURE get_employee_details (p_employee_id IN NUMBER)
IS
    v_first_name  Employees.FirstName%TYPE;
    v_last_name   Employees.LastName%TYPE;
    v_salary      Employees.Salary%TYPE;
BEGIN
    -- Retrieve employee details based on the provided employee ID
    SELECT FirstName, LastName, Salary
    INTO v_first_name, v_last_name, v_salary
    FROM Employees
    WHERE EmployeeID = p_employee_id;

    -- Print employee details
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || p_employee_id);
    DBMS_OUTPUT.PUT_LINE('First Name: ' || v_first_name);
    DBMS_OUTPUT.PUT_LINE('Last Name: ' || v_last_name);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);
END;
/

Explanation:
============
1. CREATE OR REPLACE PROCEDURE is the syntax for creating a new stored procedure or replacing
an existing one.
2. get_employee_details is the name of the stored procedure.
3. (p_employee_id IN NUMBER) is the input parameter declaration. The procedure expects an
employee ID as input.
4. IS marks the beginning of the procedure's executable section.
5. v_first_name, v_last_name, and v_salary are local variables used to store employee details
retrieved from the database.
6. The SELECT INTO statement retrieves the FirstName, LastName, and Salary of the employee
with the provided EmployeeID and stores them in the respective variables.
7. The DBMS_OUTPUT.PUT_LINE statements print the employee details.
8. END; marks the end of the procedure.

CREATE OR REPLACE PROCEDURE calculate_order_total (
  order_id IN NUMBER
)
AS
  total_amount NUMBER;
BEGIN
  SELECT SUM(unit_price * quantity) INTO total_amount
  FROM order_items
  WHERE order_id = calculate_order_total.order_id;

  DBMS_OUTPUT.PUT_LINE('Total amount for order ' || order_id || ': ' || total_amount);
END;
/

BEGIN
    get_employee_details(1001); -- Example employee ID
END;
/

Explanation:
============
1. This procedure calculate_order_total takes an order_id as input.
2. It calculates the total amount for the order by summing the product of unit price and
quantity from the order_items table.
3. The result is stored in the total_amount variable.
4. Finally, it displays the total amount using DBMS_OUTPUT.PUT_LINE.

** Procedure with Parameters **
===============================
CREATE PROCEDURE GetEmployeeDetails
AS
BEGIN
    SELECT * from Employees;
END
/

EXEC GetEmployeeDetails;

** Procedure with Parameters - IN **
====================================
CREATE PROCEDURE GetEmployeeDetail ( EmpId IN Number)
AS
BEGIN
    SELECT * from Employees where EmpId = GetEmployeeDetail.EmpId;
END
/

** Procedure with Parameters - IN & OUT **
==========================================
variable n1 number;
CREATE OR REPLACE PROCEDURE GetSalary(eid IN Employees.EmpId%type,
sal OUT Employees.EmpSal%type) IS
BEGIN
    SELECT EmpSal INTO sal from Employees where EmpId = eid;
END
/

execute GetSalary(101, :n1);
print :n1;

N1
-----
50000



